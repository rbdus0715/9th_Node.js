- 환경 변수
    
    환경변수란 프로그램이 동작하는 환경 정보를 저장해두는 변수이다. 프로그램이 실행될 때 환경변수에 따라 다르게 작동하도록 정보를 전달한다.
    
    보통 .env 파일에 담아두고, dotenv 라이브러리를 통해서 process.env.PORT.변수 이렇게 사용한다.
    
    만약 환경변수가 없다면 코드에 일일이 그 값을 하드코딩해야 하기 때문에 수정 시에 엄청나게 번거로울 것이고, 애초에 환경변수는 중요한 정보이기 때문에 하드코딩 하는 것은 바람직하지 않다.
    
    .env 파일은 해당 디렉터리에서 환경변수인 반면,
    
    리눅스, 맥OS에서 
    
    ```bash
    export 변수명=값
    echo $변수명
    ```
    
    와 같이 모든 프로그램에서 접근할 수 있다. 
    
    이와같이 환경변수를 세팅해놓으면 makefile이나 다양한 자동화 도구를 만들때, 혹은 프로젝트를 진행할 때 미리 세팅한 정보를 가져와 편리하게 작업할 수 있다.
    
- CORS
    
    cors, 한국어로 번역하면 교차 출처 리소스 공유이다.
    
    브라우저가 자신의 출처가 아닌 다른 어떤 출처로부터 자원을 로딩하는 것을 허용하도록 서버가 허가해주는 http 헤더 기반 메커니즘이다.
    
    예시로, 다음 브라우저에서 네이버 백엔드 api에 접근한다고 하면, 네이버 백엔드에서 cors를 허용해줘야 필요한 기능이 뭔지 파악하고, 다음 브라우저에서 그 api를 사용할 수 있다.
    
    이를 통해 악의적으로 만들어진 피싱사이트가 백엔드 API를 자유롭게 호출할 수 있게 되는 것을 사전에 방지한다.
    
    cors를 하지 않으면 CSRF, cross site request forgery 해킹 방법에 취약해진다.
    
    다음 브라우저에서 로그인 성공해서 다음 백엔드로부터 쿠기(로그인 증포)를 받은 상태이다. 실수로 다음 사이트와 비슷하게 생긴 해커 사이트에 접속했는데, 해커 사이트에서 다음 백엔드로 게시물 삭제 요청을 보낸 것이다. 위에서 로그인 할 때 받은 쿠키는 어떤 사이트에서든 사용될 수 있기 때문에 이 쿠키를 남용하여 daun 사이트에서 daum 백엔드에 요청을 한 것이다.
    
    이때 다음 백엔드가 cors 허용이라면 게시물이 삭제되겠지만, cors 금지 설정을 해놓아 다음 사이트가 아니라면 그런 접근을 애초에 브라우저에서 차단한다.
    
- DB Connection, DB Connection Pool
    
    디비 커넥션 풀은 데이터베이스 연결을 미리 생성해두고, 필요할 때마다 이를 재사용하는 기술이다. DB 커넥션을 새로 생성하는 것은 많은 시간과 자원을 소모하기 때문이다.
    
    애플리케이션과 DB간 연결은 네트워크를 통해 이뤄지고, 이 과정에서 TCP/IP 핸드셰이크와 같은 여려 단계를 거쳐야한다. 이 과정은 연결시 상당한 시간을 소모하게 만든다.
    
    그렇기에 미리 DB 커넥션 풀을 사용하면 미리 생성해둔 연결을 재사용해 시간을 절약하고 애플리케이션 성능을 향상시킬 수 있다.
    
    DB 커넥션 풀 설정은
    
    - 최소 연결수: 연결의 최대 개수, 서버가 시작될 때 이 수만큼 미리 생성된다.
    - 최대 연결수: 풀이 관리할 수 있는 최대 개수, 동시에 처리할 수 있는 요청의 수와 직접적으로 관련 있음. 낮게 설정하면 요청이 많을 때 응답이 길어질 수 있고, 너무 높다면 불필요한 자원을 소모하게 된다.
    - 연결 대기 시간: 풀에서 사용 가능한 연결을 기다리는 최대 시간을 의미한다. 이 시간이 초과되면 예외가 발생한다. 적절한 대기시간 설정을 통해 리소스 사용과 응답 시간 사이의 균형을 맞춰야한다.
    
    등 설정으로 구성된다.
    
    최소 연결
    
    최적화 전략
    
    1. 애플리케이션 실제 트래픽 패턴을 분석해 최소 연결 수 와 최대 연결 수 를 적절하게 설정하기: 피크 타임에도 충분한 연결을 제공하면서 비활성 시간에는 자원 낭비 최소화
    2. 유휴 연결 검사와 연결 유효성 검사를 활성: 불필요하게 자원 소모하는 연결 정리하고, 항상 유효한 연결만 유지 > 애플리케이션 안정성 높이는데 도움
    3. 디비 커넥션 풀 라이브러리 중 애플리케이션 요구 사항에 가장 적합한 것 선택하기. > Hikari CP
    
    이상적인 connection pool의 크기는?
    
    mysql 공식 문서에서는 600명 유저에 대해 15~20개의 풀 크기가 적당하다고 언급되어있다.
    
    추가로 우아한형제들 기술블로그에서는 Tn: 전체 Thread 개수, Cm: 하나의 테스크에서 동시에 필요한 커넥션 수라고 할 때
    
    ![image.png](attachment:d7eec14b-badf-4ef5-9965-f7ee48b68e95:image.png)
    
    다음 공식을 언급하고 있다.
    
    HikariCP가 빠른 이유
    
    - 적은 메모리 사용량: HikariCP는 매우 적은 메모리를 사용하므로 초기화 및 연결 시간이 짧다.
    - 높은 처리량: HikariCP는 매우 빠르게 연결을 생성하고 반환하기 때문에 처리량이 매우 높다.
    - 작은 코드 베이스: HikariCP는 코드 베이스가 작기 때문에 구성이 간단하고 가볍다.
    - 풍부한 구성 옵션: HikariCP는 다양한 구성 옵션을 제공하여 애플리케이션에 최적화된 커넥션 풀을 생성할 수 있다.
    - 스레드 안전성: HikariCP는 스레드 안전하게 설게되어 있으므로 여러 스레드에서 안전하게 사용할 수 있다.
    
- 비동기 (async, await)
    
    Async와 await는 Promise를 감싸서 동기코드처럼 코드를 짤 수 있게 해준다.
    
    일반적인 동기 코드는 다음과 같다.
    
    ```bash
    function getUser() {
    	return "해피잭"
    }
    ```
    
    이는 실행 시 바로 반환 결과를 얻게 된다.
    
    여기서 function 앞에 async를 붙이면?
    
    반환 결과로 Promise를 받게 되고 그 안에 result로 “해피잭”을 받게 된다.
    
    ```jsx
    async function getUser() {
    	return "해피잭"
    }
    const user = getUser();
    user.then((name) => console.log(name));
    
    ```
    
    Promise 안의 값은 then을 사용해서 가져온다.
    
    만약 async 안에서 promise를 반환한다면?
    
    ```jsx
    const promise = new Promise(resolve => resolve("해피잭");
    async function getUser() {
    	return promise;
    }
    ```
    
    이럴 때는 프로미스가 또 프로미스로 감싸지는 것이 아니라, 그 상태로 반환되게 된다.
    
    ```jsx
    function network() {
    	return new Promise((resolve) => {
    		setTimeout(() => {
    			console.log("데이터");
    			resolve();
    		}, 2000);
    	});
    }
    
    async function getUser() {
    	network(); // 비동기적으로 수행되기에 끝날때까지 수행되지 않는다.
    	return "해피잭";
    }
    
    const user = getUser();
    user.then((name) => console.log(name));
    
    // 해피잭
    // 데이터
    ```
    
    await는 이 network가 수행될 때까지 기다리는 역할을 한다.
    
    ```jsx
    await network();
    ```
    
    여러 개의 비동기 함수를 순차적으로 사용하고 싶다면??
    
    ```jsx
    await network();
    await network();
    await network();
    ```
    
    이렇게 쉽게 코딩 가능하다!
    
    만약 async, await를 사용하지 않는다면?
    
    ```jsx
    function getUserPromise() {
    	return network()
    		.then(() => {
    			return network();
    		})
    		.then(() => {
    			return "해피잭";
    		});
    }
    ```
    
    쉽지않다.
    
- try/catch/finally
    
    try-catch-finally는 예외처리 구조를 제공하는 문법이다.
    
    try-catch로 에러를 다루고, 에러 발생 여부와 상관없이 항상 실행되는 코드를 finally에 작성한다.
    
    문법
    
    - try문은 try 블록으로 시작해서 catch 또는 finally 둘 중 하나가 반드시 존재해야한다.
    - 각 블록은 단일 구문이 아닌 중괄호 {}로 감싸지 블록이다.
    
    try 블록에서 예외가 발생하면 자동적으로 예외값이 catch(e)에서 e에 저장된다.
    
    여기서 exceptionVar는 여러 값이 들어있는데, 단일 식별자일 필요 없이 구조 분해 할당을 통해 여러 개의 식별자를 할당할 수 있다.
    
    ```jsx
    try {
    	//
    } catch({name, message}) {
    	console.log(name);
    }
    ```
    
    finally문이 필요한 경우 사례
    
    ```jsx
    openMyFile();
    try {
    	writeMyFile(theData);
    } finally {
    	closeMyFile(); // 언제나 처리해야하는 코드!
    }
    ```